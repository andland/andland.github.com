<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: data | Statistically Significant]]></title>
  <link href="http://andland.github.io/blog/categories/data/atom.xml" rel="self"/>
  <link href="http://andland.github.io/"/>
  <updated>2014-01-07T19:03:31-05:00</updated>
  <id>http://andland.github.io/</id>
  <author>
    <name><![CDATA[Andrew Landgraf]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Top Songs by Artist on CD102.5 in 2013]]></title>
    <link href="http://andland.github.io/blog/2013/12/27/top-songs-by-artist-on-cd1025-in-2013/"/>
    <updated>2013-12-27T00:00:00-05:00</updated>
    <id>http://andland.github.io/blog/2013/12/27/top-songs-by-artist-on-cd1025-in-2013</id>
    <content type="html"><![CDATA[<div class='post'>
In a <a href="http://alandgraf.blogspot.com/2013/08/downloading-and-analyzing-cd1025s.html">previous post</a>, I showed you how to scrape playlist data from Columbus, OH alternative rock station <a href="http://cd1025.com/">CD102.5</a>. Since it's the end of the year and best-of lists are all the fad, I thought I would share the most popular songs and artists of the year, according to this data. In addition to this, I am going to make an interactive graph using <a href="http://www.rstudio.com/shiny/">Shiny</a>, where the user can select an artist and it will graph the <a href="http://spark.rstudio.com/andland/CD1025Playlist/">most popular songs</a> from that artist.<br /><br />First off, I am assuming that you have scraped the appropriate data using the code from the previous post.<br /><br /><pre><code class="r">library(lubridate)<br />library(sqldf)<br /><br />playlist=read.csv("CD101Playlist.csv",stringsAsFactors=FALSE)<br />dates=mdy(substring(playlist[,3],nchar(playlist[,3])-9,nchar(playlist[,3])))<br />times=hm(substring(playlist[,3],1,nchar(playlist[,3])-10))<br />playlist$Month=ymd(paste(year(dates),month(dates),"1",sep="-"))<br />playlist$Day=dates<br />playlist$Time=times<br />playlist=playlist[order(playlist$Day,playlist$Time),]</code></pre><br />Next, I will select just the data from 2013 and find the songs that were played most often. <br /><pre><code class="r">playlist=subset(playlist,Day&gt;=mdy("1/1/13"))<br />playlist$ArtistSong=paste(playlist$Artist,playlist$Song,sep="-")<br />top.songs=sqldf("Select ArtistSong, Count(ArtistSong) as Num<br />      From playlist<br />      Group By ArtistSong<br />      Order by Num DESC<br />      Limit 10")<br /></code></pre><br />The top 10 songs are the following:<br /><pre><code class="r">                              Artist-Song Number Plays<br />1  FITZ AND THE TANTRUMS-OUT OF MY LEAGUE 809<br />2                      ALT J-BREEZEBLOCKS 764<br />3              COLD WAR KIDS-MIRACLE MILE 759<br />4                      ATLAS GENIUS-IF SO 750<br />5                         FOALS-MY NUMBER 687<br />6                         MS MR-HURRICANE 679<br />7       THE NEIGHBOURHOOD-SWEATER WEATHER 657<br />8           CAPITAL CITIES-SAFE AND SOUND 646<br />9             VAMPIRE WEEKEND-DIANE YOUNG 639<br />10             THE FEATURES-THIS DISORDER 632<br /></code></pre><br />I will make a plot similar to the plots made in <a href="http://alandgraf.blogspot.com/2013/08/when-did-cd1025-book-summerfest-artists.html">the last post</a> to show when the top 5 songs were played throughout the year.<br /><pre><code class="r">    <br />plays.per.day=sqldf("Select Day, Count(Artist) as Num<br />      From playlist<br />      Group By Day<br />      Order by Day")<br /><br />playlist.top.songs=subset(playlist,ArtistSong %in% top.songs$ArtistSong[1:5])<br /><br />song.per.day=sqldf(paste0("Select Day, ArtistSong, Count(ArtistSong) as Num<br />                          From [playlist.top.songs]<br />                          Group By Day, ArtistSong<br />                          Order by Day, ArtistSong"))<br />dspd=dcast(song.per.day,Day~ArtistSong,sum,value.var="Num")<br /><br />song.per.day=merge(plays.per.day[,1,drop=FALSE],dspd,all.x=TRUE)<br />song.per.day[is.na(song.per.day)]=0<br /><br />song.per.day=melt(song.per.day,1,variable.name="ArtistSong",value.name="Num")<br />song.per.day$Alpha=ifelse(song.per.day$Num&gt;0,1,0)<br /><br />library(ggplot2)<br />ggplot(song.per.day,aes(Day,Num,colour=ArtistSong))+geom_point(aes(alpha=Alpha))+<br />  geom_smooth(method="gam",family=poisson,formula=y~s(x),se=F,size=1)+<br />  labs(x="Date",y="Plays Per Day",title="Top Songs",colour=NULL)+<br />  scale_alpha_continuous(guide=FALSE,range=c(0,.5))+theme_bw()<br /></code></pre><div class="separator" style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/-JWP3RQkgQeo/Ur4-RG1px7I/AAAAAAAAH-U/JH6gP0Jk6Tc/s1600/TopSongs.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://4.bp.blogspot.com/-JWP3RQkgQeo/Ur4-RG1px7I/AAAAAAAAH-U/JH6gP0Jk6Tc/s1600/TopSongs.png" /></a></div>Alt-J was more popular in the beginning of the year and the Foals have been more popular recently.<br /><br />I can similarly summarize by artist as well.<br /><pre><code class="r">top.artists=sqldf("Select Artist, Count(Artist) as Num<br />                From playlist<br />                Group By Artist<br />                Order by Num DESC<br />                Limit 10")<br /></code></pre><br /><pre><code class="r">                    Artist  Num<br />1                     MUSE 1683<br />2          VAMPIRE WEEKEND 1504<br />3        SILVERSUN PICKUPS 1442<br />4                    FOALS 1439<br />5                  PHOENIX 1434<br />6            COLD WAR KIDS 1425<br />7                JAKE BUGG 1316<br />8  QUEENS OF THE STONE AGE 1296<br />9                    ALT J 1233<br />10     OF MONSTERS AND MEN 1150<br /></code></pre><br /><pre><code class="r">playlist.top.artists=subset(playlist,Artist %in% top.artists$Artist[1:5])<br /><br />artists.per.day=sqldf(paste0("Select Day, Artist, Count(Artist) as Num<br />                          From [playlist.top.artists]<br />                          Group By Day, Artist<br />                          Order by Day, Artist"))<br />dspd=dcast(artists.per.day,Day~Artist,sum,value.var="Num")<br /><br />artists.per.day=merge(plays.per.day[,1,drop=FALSE],dspd,all.x=TRUE)<br />artists.per.day[is.na(artists.per.day)]=0<br /><br />artists.per.day=melt(artists.per.day,1,variable.name="Artist",value.name="Num")<br />artists.per.day$Alpha=ifelse(artists.per.day$Num&gt;0,1,0)<br /><br />ggplot(artists.per.day,aes(Day,Num,colour=Artist))+geom_point(aes(alpha=Alpha))+<br />  geom_smooth(method="gam",family=poisson,formula=y~s(x),se=F,size=1)+<br />  labs(x="Date",y="Plays Per Day",title="Top Artists",colour=NULL)+<br />  scale_alpha_continuous(guide=FALSE,range=c(0,.5))+theme_bw()<br /></code></pre><div class="separator" style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/-57hZwciuIug/Ur5AO9l7NWI/AAAAAAAAH-g/Xi2_4e-FwZw/s1600/TopArtist.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://2.bp.blogspot.com/-57hZwciuIug/Ur5AO9l7NWI/AAAAAAAAH-g/Xi2_4e-FwZw/s1600/TopArtist.png" /></a></div>The pattern for the artists are not as clear as it is for the songs.<br /><br />Finally, I wrote <a href="http://spark.rstudio.com/andland/CD1025Playlist/">a Shiny interactive app</a>. They are surprisingly easy to create and if you are thinking about experimenting with it, I suggest you try it. I will leave the code for the app in <a href="https://gist.github.com/andland/8155783">a gist</a>. In <a href="http://spark.rstudio.com/andland/CD1025Playlist/">the app</a>, you can enter any artist you want, and it will show you the most popular songs on CD102.5 for that artist. You can also select the number of songs that it plots with the slider.<br /><br />For example, even though Muse did not have one of the most popular songs of the year, they were still the band that was played the most. By typing in "MUSE" in the Artist text input, you will get the <a href="http://spark.rstudio.com/andland/CD1025Playlist/">following output</a>.<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://1.bp.blogspot.com/-EuKnItqFzCo/Ur5CQELkw0I/AAAAAAAAH-s/Pv4dJwueLQM/s1600/Muse.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://1.bp.blogspot.com/-EuKnItqFzCo/Ur5CQELkw0I/AAAAAAAAH-s/Pv4dJwueLQM/s1600/Muse.png" /></a></div>They had two songs that were very popular this year and a few others that were decently popular as well.<br /><br /><a href="http://spark.rstudio.com/andland/CD1025Playlist/">Play around</a> with it and let me know what you think.</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Downloading and Analyzing CD1025's Playlist]]></title>
    <link href="http://andland.github.io/blog/2013/08/20/downloading-and-analyzing-cd1025s/"/>
    <updated>2013-08-20T00:00:00-04:00</updated>
    <id>http://andland.github.io/blog/2013/08/20/downloading-and-analyzing-cd1025s</id>
    <content type="html"><![CDATA[<div class='post'>
<a href="http://www.cd101.com/">CD1025</a> is an “alternative” radio station here in Columbus. They are one of the few remaining radio stations that are independently owned and they take great pride in it. For data nerds like me, they also put a real time list of recently played songs on <a href="http://cd1025.com/about/playlists/now-playing">their website</a>. The page has the most recent 50 songs played, but you can also click on “Older Tracks” to go back in time. When you do this, the URL ends “now-playing/?start=50”. If you got back again, it says “now-playing/?start=100”.<br /><br />Using this structure, I decided to see if I could download all of their historical data and see how far it goes back. In the code below, I use the XML package to go to the website and download the 50 songs and then increment the number by 50 to find the previous 50 songs. I am telling the code to keep doing this until I get to January 1, 2012.<br /><pre><code class="r">library(ggplot2)<br />theme_set(theme_bw())<br />library(XML)<br />library(lubridate)<br />library(sqldf)<br />startNum = 0<br />while (TRUE) {<br />    theurl &lt;- paste0("http://cd1025.com/about/playlists/now-playing/?start=", <br />        startNum)<br />    table &lt;- readHTMLTable(theurl, stringsAsFactors = FALSE)[[1]]<br />    if (startNum == 0) {<br />        playlist = table[, -1]<br />    } else {<br />        playlist = rbind(playlist, table[, -1])<br />    }<br />    dt = mdy(substring(table[1, 4], nchar(table[1, 4]) - 9, nchar(table[1, 4])))<br />    print(dt)<br />    if (dt &lt; mdy("1/1/12")) {<br />        break<br />    }<br />    startNum = startNum + 50<br />}<br /><br />playlist = unique(playlist)  # Remove Dupes<br /><br />write.csv(playlist, "CD101Playlist.csv", row.names = FALSE)<br /></code></pre>This takes a while and is fairly large. My file has over 150,000 songs. If you want just a little data, change the date to last week or so. The first thing I will do is parse the dates and times of the songs, order them, and look at the first few songs. You can see that data only goes back to March of 2012.<br /><pre><code class="r">dates = mdy(substring(playlist[, 3], nchar(playlist[, 3]) - 9, nchar(playlist[, <br />    3])))<br />times = hm(substring(playlist[, 3], 1, nchar(playlist[, 3]) - 10))<br />playlist$Month = ymd(paste(year(dates), month(dates), "1", sep = "-"))<br />playlist$Day = dates<br />playlist$Time = times<br />playlist = playlist[order(playlist$Day, playlist$Time), ]<br />head(playlist)<br /></code></pre><pre><code>##                     Artist                Song       Last.Played<br />## 151638 DEATH CAB FOR CUTIE   YOU ARE A TOURIST 12:34am03/01/2012<br />## 151637       SLEEPER AGENT          GET BURNED 12:38am03/01/2012<br />## 151636          WASHED OUT           AMOR FATI 12:41am03/01/2012<br />## 151635            COLDPLAY       CHARLIE BROWN 12:45am03/01/2012<br />## 151634           GROUPLOVE         TONGUE TIED 12:49am03/01/2012<br />## 151633               SUGAR YOUR FAVORITE THING 12:52am03/01/2012<br />##             Month        Day   Time<br />## 151638 2012-03-01 2012-03-01 34M 0S<br />## 151637 2012-03-01 2012-03-01 38M 0S<br />## 151636 2012-03-01 2012-03-01 41M 0S<br />## 151635 2012-03-01 2012-03-01 45M 0S<br />## 151634 2012-03-01 2012-03-01 49M 0S<br />## 151633 2012-03-01 2012-03-01 52M 0S<br /></code></pre>Using the sqldf package, I can easily see what the most played artists and songs are from the data I scraped.<br /><pre><code class="r">sqldf("Select Artist, Count(Artist) as PlayCount<br />       From playlist<br />       Group By Artist<br />       Order by PlayCount DESC<br />       Limit 10")<br /></code></pre><pre><code>##                   Artist PlayCount<br />## 1      SILVERSUN PICKUPS      2340<br />## 2         THE BLACK KEYS      2203<br />## 3                   MUSE      1988<br />## 4              THE SHINS      1885<br />## 5    OF MONSTERS AND MEN      1753<br />## 6            PASSION PIT      1552<br />## 7              GROUPLOVE      1544<br />## 8  RED HOT CHILI PEPPERS      1514<br />## 9                 METRIC      1495<br />## 10          ATLAS GENIUS      1494<br /></code></pre><pre><code class="r"><br />sqldf("Select Artist, Song, Count(Song) as PlayCount<br />      From playlist<br />      Group By Artist, Song<br />      Order by PlayCount DESC<br />      Limit 10")<br /></code></pre><pre><code>##                 Artist                    Song PlayCount<br />## 1          PASSION PIT             TAKE A WALK       828<br />## 2    SILVERSUN PICKUPS                PIT, THE       825<br />## 3         ATLAS GENIUS                 TROJANS       819<br />## 4        WALK THE MOON                ANNA SUN       742<br />## 5       THE BLACK KEYS LITTLE BLACK SUBMARINES       736<br />## 6          DIVINE FITS  WOULD THAT NOT BE NICE       731<br />## 7        THE LUMINEERS                  HO HEY       722<br />## 8       CAPITAL CITIES          SAFE AND SOUND       712<br />## 9  OF MONSTERS AND MEN          MOUNTAIN SOUND       711<br />## 10               ALT J            BREEZEBLOCKS       691<br /></code></pre>I am a little surprised that Silversun Pickups are the number one band, but everyone on the list makes sense. Looking at how the plays of the top artists have varied from month to month, you can see a few patterns. Muse has been more popular recently and The Shins and Grouplove have lost some steam.<br /><pre><code class="r">artist.month=sqldf("Select Month, Artist, Count(Song) as Num<br />      From playlist<br />      Group By Month, Artist<br />      Order by Month, Artist")<br />artist=sqldf("Select Artist, Count(Artist) as Num<br />      From playlist<br />      Group By Artist<br />      Order by Num DESC")<br />p=ggplot(subset(artist.month,Artist %in% head(artist$Artist,8)),aes(Month,Num))<br />p+geom_bar(stat="identity",aes(fill=Artist),position='fill',colour="grey")+</code></pre><pre><code class="r"> labs(y="Percentage of Plays")</code></pre><div class="separator" style="clear: both; text-align: center;"><a href="http://3.bp.blogspot.com/-ZbWCMOMUX8E/UhPvnh1UoqI/AAAAAAAAH8I/EIAlTwFKjxg/s1600/PlayProportionByMonth.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://3.bp.blogspot.com/-ZbWCMOMUX8E/UhPvnh1UoqI/AAAAAAAAH8I/EIAlTwFKjxg/s1600/PlayProportionByMonth.png" /></a></div><br />For the play count of the top artists, I see some odd numbers in June and July of 2012. The number of plays went way down.<br /><pre><code class="r">p + geom_area(aes(fill = Artist), position = "stack", colour = 1) + labs(y = "Number of Plays")<br /></code></pre><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://1.bp.blogspot.com/--0tLMWDJuAI/UhPvnsQAl2I/AAAAAAAAH8M/tl2RtleoH2k/s1600/PlayCountByMonth.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://1.bp.blogspot.com/--0tLMWDJuAI/UhPvnsQAl2I/AAAAAAAAH8M/tl2RtleoH2k/s1600/PlayCountByMonth.png" /></a></div><br />Looking into this further, I plotted the date and time that the song was played by the cumulative number of songs played since the beginning of the list. The plot should be a line with a constant slope, meaning that the plays per day are relatively constant. You can see in June and July of 2012 there are flat spots where there is no playlist history. <br /><pre><code class="r">qplot(playlist$Day + playlist$Time, 1:length(dates), geom = "path")<br /></code></pre><div class="separator" style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/-jzAKuFMa_ak/UhPvnqrS-_I/AAAAAAAAH8E/DgJDVUUNyD8/s1600/PlaysByTime.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://4.bp.blogspot.com/-jzAKuFMa_ak/UhPvnqrS-_I/AAAAAAAAH8E/DgJDVUUNyD8/s1600/PlaysByTime.png" /></a></div><br />There are also smaller flat spots in September and December, but I am going to decide that those are small enough not to affect any further analyses. From this, I am going to use data only from August 2012 to present.<br /><pre><code class="r">playlist = subset(playlist, Day &gt;= mdy("8/1/12"))<br /></code></pre>Next up, I am going to use this data to analyze the plays of artists from <a href="http://cd1025.com/summerfest">Summerfest</a>, and try to infer if the play counts varied once they were added to the bill.</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Copying Data from Excel to R and Back]]></title>
    <link href="http://andland.github.io/blog/2013/02/24/copying-data-from-excel-to-r-and-back_24/"/>
    <updated>2013-02-24T00:00:00-05:00</updated>
    <id>http://andland.github.io/blog/2013/02/24/copying-data-from-excel-to-r-and-back_24</id>
    <content type="html"><![CDATA[<div class='post'>
A lot of times we are given a data set in Excel format and we want to run a quick analysis using R's functionality to look at advanced statistics or make better visualizations. There are packages for importing/exporting data from/to Excel, but I have found them to be hard to work with or only work with old versions of Excel (*.xls, not *.xlsx). So for a one time analysis, I usually save the file as a csv and import it into R.<br /><br />This can be a little burdensome if you are trying to do something quick and creates a file that needs to be cleaned up later. An easier option is to copy and paste the data directly into R. This can be done by using "clipboard" as the file and specifying that it is tab delimited, since that is how Excel's clipboard stores the data.<br /><br />For example, say you have a table in excel you want to copy into R. First, copy it in Excel.<br /><div class="separator" style="clear: both; text-align: center;"><a href="http://1.bp.blogspot.com/-qPkCaCo_zWw/USpK8GLtKsI/AAAAAAAAHq0/9LrZwb05LVg/s1600/Capture.PNG" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://1.bp.blogspot.com/-qPkCaCo_zWw/USpK8GLtKsI/AAAAAAAAHq0/9LrZwb05LVg/s1600/Capture.PNG" /></a></div><div class="separator" style="clear: both; text-align: center;"></div><br />Then go into R and use this function.<br /><br /><div style="overflow: auto;"><div class="geshifilter"><pre class="r geshifilter-R" style="font-family: monospace;">read.excel &lt;- <a href="http://inside-r.org/r-doc/base/function"><span style="color: #003399; font-weight: bold;">function</span></a><span style="color: #009900;">(</span>header=<span style="color: black; font-weight: bold;">TRUE</span><span style="color: #339933;">,</span>...<span style="color: #009900;">)</span> <span style="color: #009900;">{</span><br />  <a href="http://inside-r.org/r-doc/utils/read.table"><span style="color: #003399; font-weight: bold;">read.table</span></a><span style="color: #009900;">(</span><span style="color: blue;">"clipboard"</span><span style="color: #339933;">,</span>sep=<span style="color: blue;">"<span style="color: #000099; font-weight: bold;">\t</span>"</span><span style="color: #339933;">,</span>header=header<span style="color: #339933;">,</span>...<span style="color: #009900;">)</span><br /><span style="color: #009900;">}</span><br />&nbsp;<br />dat=read.excel<span style="color: #009900;">(</span><span style="color: #009900;">)</span></pre></div></div><br />This function specifies that you are reading data from the clipboard, that it is tab delimited, and that it has a header.<br /><br />Similarly, you can copy from R to Excel using the same logic. Here I also make <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">row.name=FALSE</span> as default since I rarely have meaningful row names and they mess up the header alignment.<br /><br /><div style="overflow: auto;"><div class="geshifilter"><pre class="r geshifilter-R" style="font-family: monospace;">write.excel &lt;- <a href="http://inside-r.org/r-doc/base/function"><span style="color: #003399; font-weight: bold;">function</span></a><span style="color: #009900;">(</span>x<span style="color: #339933;">,</span><a href="http://inside-r.org/r-doc/base/row.names"><span style="color: #003399; font-weight: bold;">row.names</span></a>=<span style="color: black; font-weight: bold;">FALSE</span><span style="color: #339933;">,</span>col.names=<span style="color: black; font-weight: bold;">TRUE</span><span style="color: #339933;">,</span>...<span style="color: #009900;">)</span> <span style="color: #009900;">{</span><br />  <a href="http://inside-r.org/r-doc/utils/write.table"><span style="color: #003399; font-weight: bold;">write.table</span></a><span style="color: #009900;">(</span>x<span style="color: #339933;">,</span><span style="color: blue;">"clipboard"</span><span style="color: #339933;">,</span>sep=<span style="color: blue;">"<span style="color: #000099; font-weight: bold;">\t</span>"</span><span style="color: #339933;">,</span><a href="http://inside-r.org/r-doc/base/row.names"><span style="color: #003399; font-weight: bold;">row.names</span></a>=<a href="http://inside-r.org/r-doc/base/row.names"><span style="color: #003399; font-weight: bold;">row.names</span></a><span style="color: #339933;">,</span>col.names=col.names<span style="color: #339933;">,</span>...<span style="color: #009900;">)</span><br /><span style="color: #009900;">}</span><br />&nbsp;<br />write.excel<span style="color: #009900;">(</span>dat<span style="color: #009900;">)</span></pre></div></div><a href="http://www.inside-r.org/pretty-r" title="Created by Pretty R at inside-R.org">Created by Pretty R at inside-R.org</a><br /><br />These functions can be added to you .RProfile so that they are always ready for a quick analysis!<br /><br />Obviously, this technique does not encourage reproducible research. It is meant to be used for quick, ad hoc analysis and plotting; not something you would use for an analysis that needs to be done on a regular basis.<br /><br /></div>


<h2>Comments</h2>


<div class='comments'>
<div class='comment'>
<div class='author'>Justin Tapp</div>
<div class='content'>
I&#39;m using this function in R for Windows. When I view the data numerically, it&#39;s fine. But when I go to plot the data I get nonsense. How to describe it...the window has 0 to 250 on the x-axis (regardless of my data series) and white boxes across the middle. </div>
</div>
<div class='comment'>
<div class='author'>Marek Sz</div>
<div class='content'>
I create similar functions and got few tips. For reading from excel following settings can be useful:<br />na.strings = &quot;&quot; # to prevent replacing NA string to missing value<br />comment.char = &quot;&quot; # to not loose everything after # sign<br />quote = &quot;&quot; # or &#39; or &quot; could mess with data<br />check.names = FALSE # if you want column names as in excel (spaces, special characters, etc.). You need to use `column name` in R to reference such columns.<br /><br />For writing na=&quot;&quot; replace missing values by empty string and not &quot;NA&quot; as on default.<br /><br />Second thing is that you can increase size of clipboard by using e.g. &quot;clipboard-10240&quot; instead of &quot;clipboard&quot; (it&#39;s a size in Kb, so it&#39;s around 10Mb; see help for connection, section Clipboard) which allow to copy and paste larger tables.</div>
</div>
<div class='comment'>
<div class='author'>Anonymous</div>
<div class='content'>
rkward (http://rkward.sourceforge.net/) has a very nifty feature (Edit -&gt; Paste Special...), that allows you to paste the copied data directly into your R source code, already formatted as a single string, vector or matrix. </div>
</div>
<div class='comment'>
<div class='author'>William Yarberry</div>
<div class='content'>
Excellent article.  Real people are always busy and this is just the kind of article that helps us all.  I have been doing scan() but when you start entering a few thousand rows that way, it gets a bit slow.  </div>
</div>
<div class='comment'>
<div class='author'>Anonymous</div>
<div class='content'>
scan() allows you to just paste...<br /><br />y &lt;- scan()</div>
</div>
<div class='comment'>
<div class='author'>Anonymous</div>
<div class='content'>
Thank you for these!!<br /></div>
</div>
<div class='comment'>
<div class='author'>Anonymous</div>
<div class='content'>
Thank you for the tip, this will help me a lot.<br />Also, it seems that, libreOffice also uses clipboard to store copied things. This function also works for libreOffice</div>
</div>
<div class='comment'>
<div class='author'>Anonymous</div>
<div class='content'>
I can&#39;t resist: you could just use<br />read.delim(&quot;clipboard&quot;)<br /><br />(The &quot;clipboard&quot; parameter is &#39;doze only for the foreseeable future)<br /><br />From &quot;?read.delim&quot;<br />read.delim(file, header = TRUE, sep = &quot;\t&quot;, quote=&quot;\&quot;&quot;, dec=&quot;.&quot;,<br />           fill = TRUE, comment.char=&quot;&quot;, ...)</div>
</div>
<div class='comment'>
<div class='author'>Anonymous</div>
<div class='content'>
Thank you very much Tony for your quick answer (on a  Sunday afternoon!!). <br /><br />Ernesto</div>
</div>
<div class='comment'>
<div class='author'>Tony Hirst</div>
<div class='content'>
@Ernesto It seems that on a Mac, you can use pbpaste ( http://stackoverflow.com/questions/9035674/r-function-to-copy-to-clipboard-on-mac-osx )<br /><br />read.clipboard.mac &lt;- function(header=TRUE,...) {<br />  read.table(pipe(&quot;pbpaste&quot;),sep=&quot;\t&quot;,header=header,...)<br />}<br /> </div>
</div>
<div class='comment'>
<div class='author'>Anonymous</div>
<div class='content'>
Thank you very much. Very useful. I work in both Windows and Mac Environments. The trick you show seems to work only in Windows. Any idea what to do in Mac? Thanks in advance,<br /><br />Ernesto</div>
</div>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The Magical Sparse Matrix]]></title>
    <link href="http://andland.github.io/blog/2012/07/20/the-magical-sparse-matrix/"/>
    <updated>2012-07-20T00:00:00-04:00</updated>
    <id>http://andland.github.io/blog/2012/07/20/the-magical-sparse-matrix</id>
    <content type="html"><![CDATA[<div class='post'>
I have been toying around with Kaggle's <a href="http://www.kaggle.com/c/msdchallenge/">Million Song Dataset Challenge</a> recently because I have some interest in <a href="http://en.wikipedia.org/wiki/Collaborative_filtering">collaborative filtering</a> (using <a href="http://www2.research.att.com/%7Evolinsky/papers/ieeecomputer.pdf" target="_blank">matrix factorization</a>). I haven't made much progress with the competition (all 3 of my submissions are below the baseline), but I have learned a few things about dealing with large amounts of data.<br /><br />The goal of the competition is to predict the 500 most likely songs each of 110,000 users will listen to next. As the name implies, there are 1,000,000 songs in the full dataset. To simplify things, I decided to concentrate on the most popular songs. I created a 110,000 x 2,000 matrix of 0's and 1's. Row i, column j is 1 if user i had listened to song j (the jth most popular song) and 0 if user i had not. As you can imagine, there are a lot more 0's than 1's in this matrix. The first few rows and columns look like this:<br /><br /><div style="font-family: &quot;Courier New&quot;,Courier,monospace;"><span style="font-size: small;">0 0 1 0 0 0 1 0 0 1 0 0 1 0 0 0 0 0 0 0 0 0 ...</span></div><div style="font-family: &quot;Courier New&quot;,Courier,monospace;"><span style="font-size: small;">0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ...</span></div><div style="font-family: &quot;Courier New&quot;,Courier,monospace;"><span style="font-size: small;">1 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ...</span></div><div style="font-family: &quot;Courier New&quot;,Courier,monospace;"><span style="font-size: small;">...</span></div><br />This matrix was about 430 Mb and took a while to load into MATLAB. So I wisened up and created a <a href="http://en.wikipedia.org/wiki/Sparse_matrix">sparse matrix</a>. A sparse matrix realizes that most of the values are 0's and does not record them. Instead, it lists the locations of the non-zero elements and what the value is. For example, this is what the first few rows of the sparse matrix looks like:<br /><br /><div style="font-family: &quot;Courier New&quot;,Courier,monospace;"><span style="font-size: small;">1 3 1<br />1 7 1<br />1 10 1<br />1 13 1<br />1 82 1<br />1 717 1<br />2 1111 1<br />2 2972 1<br />2 3516 1</span></div><div style="font-family: &quot;Courier New&quot;,Courier,monospace;"><span style="font-size: small;">...</span></div><br />The first column is the row number, the second is the column number, and the third is the value at that location. In this application, all the values are 1. For this matrix, I used the 50,000 most popular songs (instead of just 2,000), and the size was much smaller -- just 17 Mb.<br /><br />It is easy to load the sparse matrix into MATLAB with the <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">spconvert</span> command, and many of MATLAB's functions (like singular value decomposition) are optimized for sparse matrices.</div>

]]></content>
  </entry>
  
</feed>
