<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: spectral clustering | Statistically Significant]]></title>
  <link href="http://andland.github.io/blog/categories/spectral-clustering/atom.xml" rel="self"/>
  <link href="http://andland.github.io/"/>
  <updated>2015-01-31T13:04:06-05:00</updated>
  <id>http://andland.github.io/</id>
  <author>
    <name><![CDATA[Andrew Landgraf]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Unsupervised Image Segmentation with Spectral Clustering with R]]></title>
    <link href="http://andland.github.io/blog/2012/02/12/unsupervised-image-segmentation-with/"/>
    <updated>2012-02-12T00:00:00-05:00</updated>
    <id>http://andland.github.io/blog/2012/02/12/unsupervised-image-segmentation-with</id>
    <content type="html"><![CDATA[<div class="post">
That title is quite a mouthful. This quarter, I have been reading papers on <a href="http://en.wikipedia.org/wiki/Spectral_clustering">Spectral Clustering</a> for a reading group. The basic goal of clustering is to find groups of data points that are similar to each other. Also, data points in one group should be dissimilar to data in other clusters. This way you can summarize your data by saying there are a few groups to consider instead of all the points. Clustering is an unsupervised learning method in that there are no "true" groups that you are comparing the clusters to.<br /><br />There are many ways to do this, two of the most popular are k-means and hierarchical clustering. Spectral clustering is nice because it gives you as much flexibility as you want to define how pairs of data points are similar or dissimilar. K-means only works well for data that are grouped in elliptically shaped, whereas spectral clustering can theoretically work well for any group. For example, the data in <a href="http://www.ml.uni-saarland.de/code/pSpectralClustering/images/clusters_11b_notitle2.png" target="_blank">this image</a> is easily clustered by spectral, but would not be by k-means. The flexibility of spectral clustering can also be a burden in that there are an infinite ways to group points.<br /><br />The basic idea (and all the flexibility) behind spectral clustering is that you define the similarity between any two data points however you want, and put them in a matrix. So if you have 100 data points, you will end up with a 100x100 matrix, where the rth row and cth column is the similarity between the rth data point and the cth data point. You can define "similarity" any way you want. Popular methods are Euclidean distance, a kernel function of the Euclidean distance, or a k nearest neighbors approach.<br /><br />Once you have the similarity matrix, you need to create a normalized/unnormalized <a href="http://en.wikipedia.org/wiki/Laplacian_matrix">Laplacian</a> matrix, then calculate the eigenvectors and eigenvalues of the the Laplacian. Finally, use the k-means algorithm on the eigenvalues corresponding to the k smallest eigenvectors. This will give you k clusters (something else you need to specify).<br /><br />The other day, someone in my office was working a project of <a href="http://en.wikipedia.org/wiki/Image_segmentation">Image Segmentation</a> (a topic I know nothing about) for a machine learning class. I thought this would be a perfect application for spectral clustering because you can define similarity of pixels in terms of both the contrast of the pixel as well as the proximity to nearby pixels. I downloaded a few pictures from the<span id="goog_358016683"></span><span id="goog_358016684"></span> <a href="http://www.eecs.berkeley.edu/Research/Projects/CS/vision/bsds/">Berkeley Segmentation Dataset Benchmark</a> website.<br /><br />One thing I quickly found was that even these moderately sized pictures were too big to create a similarity matrix for in R. A typical image is 481x321=154401 pixels. So a similarity matrix between all the pixels would be 154401x154401=23 billion elements. R only allows 2^31-1=2.1 billion elements in a matrix. Even if I could create the matrix, it would take forever to calculate the eigenvectors and eigenvalues. [Note: Some people from my department actually tackled <a href="http://www.stat.osu.edu/~taoshi/research/papers/2011_Schuetter_Shi_JCGS.pdf" target="_blank">this exact problem</a> using sampling methods.]<br /><br />So I had to reduce the size of the image. For this I just created an image of a factor of the original dimension (about 10 to 20 times smaller), and averaged the contrast of all the points that were collapsed. I also experimented with smoothing the image first and then doing the averaging In some cases it helped in some it hurt, I think.<br /><br />For example here is an original picture.<br /><div class="separator" style="clear: both; text-align: center;"><a href="http://www.eecs.berkeley.edu/Research/Projects/CS/vision/bsds/BSDS300/html/images/plain/normal/gray/86016.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://www.eecs.berkeley.edu/Research/Projects/CS/vision/bsds/BSDS300/html/images/plain/normal/gray/86016.jpg" /></a></div><br />Then I smoothed using the image.smooth function of the fields package.<br /><div class="separator" style="clear: both; text-align: center;"><a href="http://1.bp.blogspot.com/-Rd4S9Z1Y5IE/Tzf9PWxlGII/AAAAAAAAF6M/xBUzV_EMDrE/s1600/smooth.jpeg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="https://lh3.ggpht.com/-Rd4S9Z1Y5IE/Tzf9PWxlGII/AAAAAAAAF6M/xBUzV_EMDrE/s1600/smooth.jpeg" /></a></div>Then I reduced the dimension by a factor of 10 and averaged the original pixels. The resulting image is below. You can see there is a decent loss of information in the averaging.<br /><div class="separator" style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/-tzIV9TQYHVI/Tzf9cKaR9YI/AAAAAAAAF6U/2sne_VgLUJQ/s1600/averaged.jpeg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="https://lh3.ggpht.com/-tzIV9TQYHVI/Tzf9cKaR9YI/AAAAAAAAF6U/2sne_VgLUJQ/s1600/averaged.jpeg" /></a></div><br />Finally, for the similarity, I only considered pixels that were within 3 horizontally or vertically to be similar (otherwise 0). Also, for those within 3, I used a Gaussian kernel of the difference in contrast with variance equal to 0.01. I chose this number because the variance in the data was about 0.01. Varying both of these parameters wildly affected quality of the results. I also tried using a k nearest neighbors similarity and I did not get any good results. Hence, you can see both the positive and negative of the flexibility.<br /><br />Anyway, here are the two clusters (white and black) using the unnormalized Laplacian.<br /><div class="separator" style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/-dtUccbD9WeM/TzgAJH51ZAI/AAAAAAAAF6c/eUL8YFLOETE/s1600/clusters.jpeg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="https://lh3.ggpht.com/-dtUccbD9WeM/TzgAJH51ZAI/AAAAAAAAF6c/eUL8YFLOETE/s1600/clusters.jpeg" /></a></div><br />It looks very good and encouraging for future problems. As stated before, however, I am not sure how to determine the parameters for a generic problem.<br /><br />Overlaying the cluster on the original image, you can see the two segments of the image clearly. You can also see the loss in fidelity due to reducing the size of the image.<br /><div class="separator" style="clear: both; text-align: center;"><a href="http://3.bp.blogspot.com/-FqY4mvTF2Yo/TzgKwX9ZlBI/AAAAAAAAF68/_WpfIetZVmc/s1600/overlay1b.jpeg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="https://lh3.ggpht.com/-FqY4mvTF2Yo/TzgKwX9ZlBI/AAAAAAAAF68/_WpfIetZVmc/s1600/overlay1b.jpeg" /></a></div><div class="separator" style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/-LDWLf0qEKCo/TzgAJciHcaI/AAAAAAAAF6k/c4veitNzH4A/s1600/overlay.jpeg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><br /></a></div>Here are a couple of other examples that worked well. With the airplane one, in particular, you can see that the clustering was able to identify an unusual shape. I was not able to get it to work well with more than two clusters, although I only tried one image that was not that easy.<br /><div class="separator" style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/-k-7m1FTg_fI/TzgKx9lj0XI/AAAAAAAAF7E/LDjpO3w1JBg/s1600/overlay3b.jpeg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="https://lh3.ggpht.com/-k-7m1FTg_fI/TzgKx9lj0XI/AAAAAAAAF7E/LDjpO3w1JBg/s1600/overlay3b.jpeg" /></a></div><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/-EVSnrPb3CaA/TzgD21GoJoI/AAAAAAAAF60/y6NlonQ8Nw0/s1600/overlay3.jpeg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"></a></div><div class="separator" style="clear: both; text-align: center;"><a href="http://3.bp.blogspot.com/-36TaE1FBMGg/TzgD2VmAOFI/AAAAAAAAF6s/W0SsqyG-J_M/s1600/overlay2.jpeg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="https://lh3.ggpht.com/-36TaE1FBMGg/TzgD2VmAOFI/AAAAAAAAF6s/W0SsqyG-J_M/s1600/overlay2.jpeg" /></a></div>For posterity, here is the code I used.<br /><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">############</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"># Import the image </span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">############</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">library(jpeg)<br /># http://www.eecs.berkeley.edu/Research/Projects/CS/vision/bsds/BSDS300/html/images/plain/normal/gray/86016.jpg<br />rawimg=readJPEG("segment.jpeg")<br />rawimg=t(rawimg)<br />rawimg=rawimg[,ncol(rawimg):1]<br />image(rawimg,col = grey((0:12)/12))</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"><br /></span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">############</span><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"></span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"># Smooth the image</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">############</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">library(fields)<br />smoothimg=image.smooth(rawimg,theta=2)<br />image(smoothimg,col = grey((0:12)/12))<br /></span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">############</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"># Reduce Size of Image</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">############</span><br /><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">olddim=dim(rawimg)<br />newdim=c(round(olddim/10))<br />prod(newdim)&gt;2^31<br />img=matrix(NA,newdim[1],newdim[2])<br />for (r in 1:newdim[1]) {<br />&nbsp; centerx=(r-1)/newdim[1]*olddim[1]+1<br />&nbsp; lowerx=max(1,round(centerx-olddim[1]/newdim[1]/2,0))<br />&nbsp; upperx=min(olddim[1],round(centerx+olddim[1]/newdim[1]/2,0))<br />&nbsp; for (c in 1:newdim[2]) {<br />&nbsp;&nbsp;&nbsp; centery=(c-1)/newdim[2]*olddim[2]+1<br />&nbsp;&nbsp;&nbsp; lowery=max(1,round(centery-olddim[2]/newdim[2]/2,0))<br />&nbsp;&nbsp;&nbsp; uppery=min(olddim[2],round(centery+olddim[2]/newdim[2]/2,0))<br />&nbsp;&nbsp;&nbsp; img[r,c]=mean(smoothimg$z[lowerx:upperx,lowery:uppery])<br />&nbsp; }<br />}<br />image(img,col = grey((0:12)/12))</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"><br /></span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">############</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"># Convert matrix to vector</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">############</span><br /><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">imgvec=matrix(NA,prod(dim(img)),3)<br />counter=1<br />for (r in 1:nrow(img)) {<br />&nbsp; for (c in 1:ncol(img)) {<br />&nbsp;&nbsp;&nbsp; imgvec[counter,1]=r<br />&nbsp;&nbsp;&nbsp; imgvec[counter,2]=c<br />&nbsp;&nbsp;&nbsp; imgvec[counter,3]=img[r,c]<br />&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp; counter=counter+1<br />&nbsp; }<br />}<br /><br /></span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">############</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"># Similarity Matrix</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">############</span><br /><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">pixdiff=2<br />sigma2=.01 #</span><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">var(imgvec[,3])</span><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"><br />simmatrix=matrix(0,nrow(imgvec),nrow(imgvec))<br />for(r in 1:nrow(imgvec)) {<br />&nbsp; cat(r,"out of",nrow(imgvec),"\n")<br />&nbsp; simmatrix[r,]=ifelse(abs(imgvec[r,1]-imgvec[,1])&lt;=pixdiff &amp; abs(imgvec[r,2]-imgvec[,2])&lt;=pixdiff,exp(-(imgvec[r,3]-imgvec[,3])^2/sigma2),0)<br />}<br />&nbsp;</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">############</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"># Weighted and Unweighted Laplacian</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">############</span><br /><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">D=diag(rowSums(simmatrix))<br />Dinv=diag(1/rowSums(simmatrix))<br />L=diag(rep(1,nrow(simmatrix)))-Dinv %*% simmatrix<br />U=D-simmatrix<br /></span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">############</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"># Eigen and k-means</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">############</span><br /><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">evL=eigen(L,symmetric=TRUE)<br />evU=eigen(U,symmetric=TRUE)<br /><br />kmL=kmeans(evL$vectors[,(ncol(simmatrix)-1):(ncol(simmatrix)-0)],centers=2,nstart=5)<br />segmatL=matrix(kmL$cluster-1,newdim[1],newdim[2],byrow=T)<br />if(max(segmatL) &amp; sum(segmatL==1)&lt;sum(segmatL==0)) {segmatL=abs(segmatL-1)}<br /><br />kmU=kmeans(evU$vectors[,(ncol(simmatrix)-1):(ncol(simmatrix)-0)],centers=2,nstart=5)<br />segmatU=matrix(kmU$cluster-1,newdim[1],newdim[2],byrow=T)<br />if(max(segmatU) &amp;sum(segmatU==1)&lt;sum(segmatU==0)) {segmatU=abs(segmatU-1)}</span><br /><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">############</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"># Plotting the clusters</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">############</span><br /><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">image(segmatL, col=grey((0:15)/15))<br />image(segmatU, col=grey((0:12)/12))<br /></span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">############</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"># Overlaying the original and the clusters</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">############</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">image(seq(0,1,length.out=olddim[1]),seq(0,1,length.out=olddim[2]),rawimg,col = grey((0:12)/12),xlim=c(-.1,1.1),ylim=c(-.1,1.1),xlab="",ylab="")<br /><br />segmat=segmatU<br />linecol=2<br />linew=3<br />for(r in 2:newdim[1]) {<br />&nbsp; for (c in 2:newdim[2]) {<br />&nbsp;&nbsp;&nbsp; if(abs(segmat[r-1,c]-segmat[r,c])&gt;0) {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xloc=(r-1)/(newdim[1])<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ymin=(c-1)/(newdim[2])<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ymax=(c-0)/(newdim[2])<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; segments(xloc,ymin,xloc,ymax,col=linecol,lwd=linew)<br />&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; if(abs(segmat[r,c-1]-segmat[r,c])&gt;0) {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; yloc=(c-1)/(newdim[2])<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xmin=(r-1)/(newdim[1])<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xmax=(r-0)/(newdim[1])<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; segments(xmin,yloc,xmax,yloc,col=linecol,lwd=linew)<br />&nbsp;&nbsp;&nbsp; }<br />&nbsp; }<br />}</span></div>
]]></content>
  </entry>
  
</feed>
